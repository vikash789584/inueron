@@ -0,0 +1,163 @@
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "56d6bdad",
   "metadata": {},
   "source": [
    "## 1) . What is the difference between enclosing a list comprehension in square brackets and parentheses?\n",
    "\n",
    "Ans:-In Python, square brackets [] are used to create lists, while parentheses () can be used to create tuples, to specify order of operations, and to group expressions.\n",
    "\n",
    "In the context of list comprehensions, enclosing the expression in square brackets creates a list, while enclosing it in parentheses creates a generator object.\n",
    "\n",
    "A list comprehension creates a list by iterating over an iterable and applying an expression to each element of the iterable, which is enclosed in square brackets. For example:\n",
    "\n",
    "squares = [x**2 for x in range(5)]\n",
    "\n",
    "squares\n",
    "\n",
    "[0, 1, 4, 9, 16]\n",
    "\n",
    "\n",
    "A generator expression, on the other hand, returns a generator object that produces a sequence of values on the fly, rather than creating a list all at once. This can be more memory-efficient for large datasets, since the generator produces only one value at a time. A generator expression is enclosed in parentheses. For example:\n",
    "\n",
    "squares = (x**2 for x in range(5))\n",
    "\n",
    "squares\n",
    "\n",
    "<generator object <genexpr> at 0x7f82f89c8200>\n",
    "    \n",
    "for square in squares:\n",
    "    \n",
    "print(square)\n",
    "    \n",
    "0\n",
    "    \n",
    "1\n",
    "    \n",
    "4\n",
    "    \n",
    "9\n",
    "    \n",
    "16\n",
    "\n",
    "    \n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d9651274",
   "metadata": {},
   "source": [
    "## 2) What is the relationship between generators and iterators?\n",
    "\n",
    "Ans:-Generators and iterators are closely related concepts in Python.\n",
    "\n",
    "An iterator is an object that provides sequential access to a collection of data. It can be used to traverse through a sequence of values, one at a time. In Python, any object that has an iter() method is an iterator.\n",
    "\n",
    "A generator is a special type of iterator that is defined using a function rather than a class. When a generator function is called, it returns an iterator object that can be used to iterate over the generated values. Unlike regular iterators, generators generate values on the fly rather than storing them in memory all at once.\n",
    "\n",
    "In other words, generators are a type of iterator that are defined using a function, while iterators can be defined using both classes and functions. A generator is a convenient way to create an iterator in cases where the values can be computed on the fly rather than being precomputed and stored in memory."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7eb9341d",
   "metadata": {},
   "source": [
    "## 3) What are the signs that a function is a generator function?\n",
    "\n",
    "Ans:-A generator function is a special type of function in Python that returns an iterator. It is denoted by the use of the yield keyword instead of the return keyword.\n",
    "\n",
    "A generator function is characterized by:\n",
    "\n",
    "The presence of one or more yield statements\n",
    "\n",
    "The use of the yield keyword to return values one at a time, instead of returning all values at once\n",
    "\n",
    "The state of the function is saved between successive calls to yield, so that execution can be resumed where it left off\n",
    "\n",
    "The function returns an iterator object, which can be used to iterate over the values generated by the function.\n",
    "\n",
    "So, if a function contains yield statements instead of return statements, it is likely a generator function."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "24bee1fc",
   "metadata": {},
   "source": [
    "## 4) What is the purpose of a yield statement?\n",
    "\n",
    "Ans:-The yield statement is used in a generator function to produce a sequence of values that can be iterated over, one value at a time. When the yield statement is executed, it pauses the generator function, saves its state, and sends the value to the caller. The next time the generator is called, execution continues from where it left off, and the function continues to produce the next value in the sequence until there are no more values to produce.\n",
    "\n",
    "The primary purpose of a yield statement is to allow generators to produce values on-the-fly, without having to create and return a list or other sequence containing all the values at once. This can save memory and improve performance, especially when dealing with large sequences."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c5fdbef7",
   "metadata": {},
   "source": [
    "## 5) What is the relationship between map calls and list comprehensions? Make a comparison and contrast between the two.\n",
    "\n",
    "Ans:-Both map calls and list comprehensions are used to apply a given function to each element of an iterable, but they have some differences.\n",
    "\n",
    "Map calls return a map object, which is an iterator that generates the results of applying the function to the elements of the iterable one at a time. A list comprehension, on the other hand, returns a list containing the results of applying the function to the elements of the iterable.\n",
    "\n",
    "Here's an example using a map call:\n",
    "\n",
    "numbers = [1, 2, 3, 4, 5]\n",
    "\n",
    "squares = map(lambda x: x**2, numbers)\n",
    "\n",
    "print(squares)  # prints <map object at 0x7f8296d27460>\n",
    "\n",
    "print(list(squares))  # prints [1, 4, 9, 16, 25]\n",
    "\n",
    "\n",
    "And here's the same example using a list comprehension:\n",
    "\n",
    "numbers = [1, 2, 3, 4, 5]\n",
    "\n",
    "squares = [x**2 for x in numbers]\n",
    "\n",
    "print(squares)  # prints [1, 4, 9, 16, 25]\n",
    "\n",
    "\n",
    "In general, list comprehensions are more concise and easier to read than map calls, especially for simple operations. Map calls can be useful when working with large datasets because they return an iterator instead of a list, which can save memory. However, in many cases, list comprehensions are preferred because they are more Pythonic and easier to understand."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4e98a9c1",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
